<p align="center" style="font-size:50px">
  <a href="https://github.com/lsw6684/ComputerScience">HOME</a>
</p>

***

<br />

# Compiler Construction
- [Compiler](#Compiler)

<br />

## Compiler
원시 언어(source language)를 목표 언어(target language)로 번역합니다.

### Compiler VS Interpreter ★
- 컴파일러는 원시 프로그램을 입력 받아 목표 프로그램으로 변환하며, 프로그램의 실행은 목표 프로그램이 입력을 받아 출력을 내놓는 것입니다.
- 인터프리터는 원시 프로그램 자체와 입력을 모두 받습니다. 이를 내부적으로 번역(interpret)하여 실행하고 출력합니다. 즉, 목표 프로그램을 생성하는 과정이 없습니다.
- 일반적으로 컴파일러가 생성한 목표 프로그램의 실행 속도가 인터프리터에 비해 빠르다는 장점이 있으며, 인터프리터는 코드를 한 줄씩 실행하는 형태이므로 오류가 발생한 경우 보다 자세한 오류 메시지를 표시할 수 있는 장점이 있습니다.

### 혼합형 컴파일러
- 자바의 경우 원시 언어로 작성된 코드를 바이트코드로 우선 변환 - *컴파일러*
- 해당 바이트코드를 JVM에서 읽고 실행 - *인터프리터*
- JVM이 인터프리터가 되어 바이트코드를 처리하므로 어떤 기계에서도 동일한 바이트코드를 실행합니다.
- 위와 같은 이유로 실행속도가 상대적으로 느립니다. 이러한 사항을 해소하기 위해 **JIT(Just In Time) 컴파일러**가 등장합니다.
    - 바이트코드를 실행하기 직전 기계어로 컴파일하여 입력을 처리합니다. 즉, 실질적으로 컴파일러와 동일한 형태로 진행되어 속도가 상대적으로 빠릅니다.

### 컴파일러의 구조
소스코드는 문자 스트림 형태로 컴파일러에 전달합니다. 다양한 단계를 통해 구문 트리 (syntax tree) 및 중간 표현 (Intermediate Representation, IR)을 거쳐 최종적으로 목표 기계 코드를 생성합니다. 이 과정에서 기계독립적(Machine independent) 코드 최적화와 기계종속적 코드 최적화를 수행합니다. 전체 과정에서 얻은 소스코드에 대한 정보를 저장하기 위해 Symbol Table이 사용됩니다.
- 분석 - 통합 구조
    - 분석(Analysis) 부분은 소스코드를 구성 요소로 분리하고, 문법적 구조를 부과합니다.
        - 이를 토대로 중간 표현(IR, 토큰 스트림 or 구문 트리)을 생성합니다.
        - 수집된 정보들은 Symbol Table에 저장됩니다.
    - 통합(Synthesis) 부분은 중간 표현과 심벌 테이블의 정보를 이용하여 목표 기계 코드를 생성합니다.

- 단계를 패스(PASS)로 통합
    - 실질적인 구현에서는 여러 단계의 동작들이 입력 파일을 읽고 출력 파일을 작성하는 패스로 통합됩니다.
    - 어휘, 구문, 의미 분석과 중간 코드 단계는 하느의 패스로 통합될 수 있습니다.
    - 이후의 최적화 부분은 선택적 패스입니다.
    - 중간표현을 매개체로 소스코드를 다양한 기계에 맞게 목적 코드로 변환하는 컴파일러를 만들 수 있습니다.
        - 기계독립적으로 변환하는 전단부 + 각 기계에 맞는 목적코드를 생성하는 후단부의 결합
- Symbol Table
    - 컴파일러의 중요한 기능은 소스코드에서 사용되는 이름을 저장하고 각 이름의 여러 가지 속성에 관한 정보를 수집하는 것입니다. 이러한 속성에는 **이름에 할당되는 기억장소, 이름의 타입, 이름의 영역(scope), 프로시저. 그리고 함수인 경우, 매개변수의 개수, 타입, 전달 방법과 반환 값에 대한 정보**등이 포함됩니다.
    - 하나의 이름에 대해 하나의 레코드를 갖는 데이터 구조입니다.
        - 컴파일러가 각 이름에 대한 레코드를 효율적으로 저장하고 추출하는 것이 가능하도록 설계되어야 합니다.

<p align="center"><img src="images/cc.png" width="65%"></p>

### 어휘 분석
Lexical Analysis, 컴파일러의 첫 단계로 스캐닝(Scanning)로도 불립니다. 소스코드에 해당하는 문자 스트림을 읽어 어휘항목(Lexeme)이라 불리는 의미있는 문자의 나열로 묶으며 각 어휘항목에 대해 어휘 분석기는 **토큰**을 출력합니다.
- `token = <토큰이름 token-name, 속성 값 attribute-value>`


