<p align="center" style="font-size:50px">
  <a href="https://github.com/lsw6684/ComputerScience">HOME</a>
</p>

***

<br />

# WEB
- [WEB](#web)
- [언어](#언어)
- [HTTP](#http)
- [WAS](#was)
- [REST, REST API, RESTful](#rest-rest-api-restful)
- [GraphQL](#graphql)
  - [REST API vs GraphQL](#rest-api-vs-graphql)

<br />

## 언어
**저급 언어 :** 기계 중심의 언어로써 기계가 알아들을 수 있는 말로 '프로그램 코드를 작성한다' 할 수 있습니다. 2진수로 작성하는 프로그래밍 언어를 ***기계어(Machine Language)*** 라고 하는데 숫자로만 되어 있기 때문에 유지보수와 사용이 어렵습니다. 이러한 이유로, 숫자로 된 문장과 1:1로 대응하는 기호인 ***어셈블리어(Assembly Language)*** 가 만들어 졌으며, 이것을 기계가 알아들을 수 있도록 원래의 숫자로 바꾸어 주는 것이 ***컴파일러(Compiler)*** 입니다.

현재는 아주 특수한 경우를 제외하고는 기계어, 어셈블리어로 개발하는 경우가 거의 없습니다. 그만큼 사용하기 어렵고 유지보수가 힘들기 때문입니다.

<br />

**고급 언어 :** 사람 중심으 언어로써 상대적으로 이해하기 쉬운 문법을 사용합니다. 이것을 번역하는 과정을 ***컴파일*** 한다고 하며, 이러한 일을 수행하는 것을 ***컴파일러*** 라고 합니다. 저급 언어의 어셈블리어를 기계어로 컴파일 하는 것과 같은 방식입니다.
- **FORTRAN :** 최초의 고급 언어 중의 하나이며, 알골과 함께 과학적 계산을 목적으로 출시된 언어입니다. 현재 공대에서도 많이 사용되고 있습니다.
-  **ALGOL :** Algorithmic Language의 준말로 포트란에 대항하여 개발된 프로그래밍 언어로, 알고리즘의 연구개발, 수치 계산과 논리 연산에 이용하기 위한 목적으로 만들어졌다.
- **COBOL :** FORTRAN과 더불어 역사가 오래된 언어로, 일반 업무에서 사용할 목적으로 만들어졌습니다. 절차적, 명령형 언어이고, 2002년부터 객체 지향을 지원했습니다. 현재도 금융, 보험 등에서 사용되고 있습니다.
- **PROLOG :** 논리형 프로그래밍 언어로써, 논리식을 토대로 오브젝트와 오브젝트 간의 관계에 관한 문제를 해결하기 위해 사용됩니다.
- **C :** 1972년 미국 벨 연구소의 데니스 리치에 의해 개발된 고급 언어로써 시스템 프로그래밍에 가장 적합한 평가를 받는 언어입니다.
- **Erlang :** 스웨덴의 에릭슨에서 개발한 함수형 병행성 프로그래밍 언어이며 통신 인프라를 위한 언어입니다.
- **Lisp :** LISt Processor의 약자로, 대표적인 함수형 언어입니다. 모든 자료는 연결 리스트로 처리하며, 컴파일 개념 없이 인터프리터 상에서 동작합니다. 현대의 컴퓨터를 위해 등장한 고급 언어 중 가장 오래된 것이 포트란이고, 두 번째가 리스프입니다.
- **Swift :** 2014년 WWDC(Apple WorldWide Developers Conference)에서 공개한 프로그래밍 언어입니다. 최근에 만들어진 언어로 현대 프로그래밍 언어의 발전을 대다수 계승한 모던 프로그래밍 언어라고 말할 수 있습니다.
-  **Kotlin :** IntelliJ IDEA의 개발사 JetBrains에서 2011년에 개발한 프로그래밍 언어입니다. JVM기반의 언어이며 Java와의 상호운영이 100% 지원됩니다. Swift와 마찬가지로 현대 프로그래밍 언어의 발전을 대다수 계층한 모던 프로그래밍 언어입니다.
-  **Clojure :** 클로저(Clojure)는 리치 히키(Rich Hickey)가 만든 리스프 프로그래밍 언어의 방언으로서, 범용 함수형 언어입니다. 자바 가상 머신과 공통 언어 런타임(CLR), 그리고 자바스크립트 엔진 상에서 실행됩니다. 다른 리스프 언어들과 같이 코드를 데이터로 취급하며, 정교한 매크로 시스템을 갖고 있습니다.
-  **Python :** 상대적으로 읽기 쉬우며 적은 코드를 사용하여 프로그램을 개발하기 때문에 생산량이 크다고 할 수 있습니다. 데이터 과학, 웹 개발, ML(Machine Learning) 등에서 많이 사용됩니다.
-  **JAVA :** 1995년 썬 마이크로 시스템즈에서 개발한 객체지향 프로그래밍 언어입니다.
-  **PHP :** 서버 측에서 실행되는 프로그래밍 언어로 HTML을 프로그래밍적으로 생성하고 데이터베이스와 상호작용을 하여 데이터를 저장하고 표현합니다. 웹을 위해 만들어졌고, 웹의 80% 이상이 PHP로 구성되어 있습니다.
-  **JavaScript** 브라우저에서 동작하는 언어로 탄생했지만, 현재는 서버에서도 사용되어지고 점차 영역을 넓히고 있습니다.
-  **Ruby :** 빠른 개발에 널리 사용되며, 단순함과 세련된 웹 어플리케이션을 만들 수 있습니다. 간결함과 생산성을 강조한 동적인 오픈 소스 프로그래밍 언어입니다.

<br />

## HTTP
HTTP는 Hypertext Transfer Protocol의 준말로 팀 버너스리와 그가 속한 팀 CERN에서 발명하였습니다. 서버와 클라이언트가 인터넷상에서 데이터를 주고 받기 위한 프로토콜이며, 어떤 종류의 데이터도 전송 가능합니다.

<p align="center"><img src="images/http.png"></p>

- **장점 :** 불특정 다수를 대상으로 하는 서비스에 적합합니다. 클라이언트와 서버간의 최대 연결수보다 훨씬 많은 요청, 응답을 처리할 수 있습니다.

- **단점 :** 무상태(Stateless)를 특징으로 정보를 유지하지 않고 연결을 끊습니다. 이를 보완하여 정보를 유지하기 위해 Cookie가 등장합니다.


```
인터넷 : TCP/IP 기반의 네트워크가 전세계적으로 확대되어 하나로 연결된 네트워크들의 네트워크 (=네트워크의 결합체)

❗
팀 버너스리가 속한 CERN은 HTTP 뿐만 아니라 웹 브라우저 및 웹 브라우저 관련 기술과 HTML도 발명.
```

**URL :** Uniform Resource Locator의 준말로 특정 웹 서버의 특정파일에 접근하기 위한 경로 혹은 주소.

<p align="center"><img src="images/URL.png" width="60%"></p>

- **GET :** 정보 요청 (SELECT)
  - URL에 데이터를 포함시켜 요청한다.
  - 데이터를 Header에 포함하여 전송한다.
  - URL에 데이터가 노출되어 보안에 취약하다.
  - 캐싱할 수 있다.

- **POST :** 정보 삽입 (INSERT)
- **PUT :** 정보 업데이트 (UPDATE)
  - URL에 데이터를 노출하지 않고 요청한다.
  - 데이터를 Body에 포함시킨다.
  - URL에 데이터가 노출되지 않아서 기본 보안은 되어있다.
  - 캐싱할 수 없다.
- **DELETE :** 정보 삭제 (DELETE)
- **HEAD :** (HTTP)헤더 정보만 요청.
  - 해당 자원이 존재하는지, 서버에 문제가 없는지 확인하기 위함.
- **OPTIONS :** 웹서버가 지원하는 메서드의 종류를 요청.
- **TRACE :** 클라이언트의 요청 반환.
  - echo 서비스로 서버 상태를 확인하기 위한 목적으로 주로 사용.

<p align="center"><img src="images/getPost.png"></p>

```
❗
캐싱 : 캐시는 컴퓨터의 성능을 향상시키기 위해 사용되는 메모리를 말하는데 이 캐시 영역으로 데이터를 가져와서 접근하는 방식을 말합니다. 
확장 시 애플리케이션의 성능을 현격히 향상시키고 비용은 크게 줄입니다.
```

<br />

## WAS
Web Application Server의 준말입니다. Browser를 Client로 본다면, Browser와 DBMS 사이에서 동작하는 미들웨어라고 볼 수 있습니다.
- 프로그램 실행 환경, DBMS 제공.
- 여러 트랜잭션을 관리.
- 업무를 처리하는 비즈니스 로직을 처리.

**Web Server** vs **WAS :** 웹서버는 보통 정적인 것을 웹 브라우저에게 전송하고 WAS는 프로그램의 동적인 결과를 웹브라우저에게 전송합니다. 현재는 WAS가 웹 서버의 정적인 기능도 내장하고 있지만, 규모가 커질수록 웹서버와 WAS를 분리하여 구축합니다. 그 이유는 ***장애 극복 기능 (Failover)*** 을 겸하기 위함입니다.

 WAS 자체에서 문제가 발생하면 WAS를 재시작 해야 하는데, 이용자들이 이 문제에 대해 영향을 받지 않고 서비스를 계속 이용할 수 있습니다.
```
❗
장애 극복 기능 (Failover) : 각종 서버, 시스템, 네트워크 등에서 이상이 생겼을 시 예비 시스템으로 자동전환되는 기능으로 서버를 이중화 하여 구현하면 무중단 운영을 시행할 수 있습니다.
```

<br />

## REST, REST API, RESTful
- **REST REpresentational State Transfer** <br />
  **자원의 표현**을 구분하여 **자원의 상태**를 주고 받는 것을 의미합니다.
    - **자원** - 해당 소프퉤어가 관리하는 모든 것. `문서, 그림, 데이터, 해당 소프트웨어 자체 등`
    - **자원의 표현** - 그 자원을 표현하기 위한 이름. `DB의 학생 정보가 자원일 때, 'students를 자원의 표현으로 정합니다.`
    - **상태 전달** - 데이터가 요청되는 자원의 상태(정보)를 전달합니다. JSON, XML을 통해 주고받는 것이 일반적입니다.
    - ### CRUD Operation
      - Create : **POST**(생성)
      - Read : **get**(읽기)
      - Update : **put**||**patch**(전체 수정 or 부분 수정)
      - Delete : **delete**(삭제)
      - HEAD : **HEAD**(header 정보 조회)

  **REST의 장점**
    - HTTP 프로토콜의 인프라를 그대로 사용하여, REST API를 위한 별도의 인프라를 구축할 필요가 없습니다.
    - HTTP 프로토콜의 표준을 최대한 활용하여 여러 추가적인 장점을 함께 가져갈 수 있게 합니다.
    - HTTP 표준 프로토콜에 따르는 모든 플랫폼에서 사용할 수 있습니다.
    - Hypermedia API의 기본을 충실히 지키면서 범용성을 보장합니다.
    - REST API 메시지가 의도하는 바를 명확하게 나타내기 때문에, 그 의도를 쉽게 파악할 수 있습니다.
    - 서비스 디자인에서 생길 수 있는 문제를 최소화합니다.
    - 서버와 클라이언트의 역할을 명확하게 분리합니다.

  **REST의 단점** 
    - 표준이 존재하지 않습니다.
    - 사용할 수 있는 메소드가 4가지뿐입니다.
      - HTTP Method 형태가 제한적입니다.
    - 구버전의 브라우저에 지원할 수 없는 부분이 존재합니다.
      - PUT, DELETE 사용 불가
      - pushState 지원 불가.
    
  **REST의 특징**
    - **Server-Client 구조**
      - REST Server : API를 제공하고 비즈니스 로직 처리 및 저장을 책임집니다.
      - Client : 사용자 인증이나 context(세션, 로그인 정보) 등을 직접 관리하고 책임집니다.
    - **무상태 Statelesss**
      - HTTP 프로토콜은 Stateless Protocol이므로 REST 역시 무상태성을 가집니다.
      - Client의 context를 Server에 저장하지 않기 때문에 세션, 쿠키와 같은 context 정보를 신경쓰지 않아도 됩니다. (구현 단순화)
      - Server는 각각의 요청을 독립적으로 인식하고 처리합니다. 처리 방식에 일관성을 부여하고 서비스의 자유도가 높아집니다.
    - **캐시 처리 가능 Cacheable**
      - 웹 표준 HTTP 프로토콜을 그대로 사용하므로 웹에서 사용하는 기존의 인프라를 그대로 사용합니다. 따라서, HTTP가 가진 강력한 특징 중 하나인 ***캐싱*** 기능을 적용할 수 있습니다.
      - 대량의 요청을 효율적으로 처리하기 위해 캐시가 요구됩니다.
      - 캐시 사용을 통해 응답시간이 빨라지고 REST Server 트랜잭션이 발생하지 않습니다. 즉, 전체 응답시간, 성능, 서버의 자원 이용률을 향상시킬 수 있습니다.
    - **계층화 Layered System**
      - Client는 REST API Server만 호출합니다.
      - REST Server는 다중 계층으로 구성될 수 있습니다.
      - PROXY, 게이트웨이 같은 네트워크 기반의 중간 매체를 사용할 수 있습니다.


- **REST API** <br />
  - **API Application Programming Interface** <br />
응용 프로그램에서 사용할 수 있도록, 운영 체제나 프로그래밍 언어가 제공하는 기능을 제어할 수 있게 만든 인터페이스입니다. 간단히 말하면, 컴퓨터의 기능을 실행시키는 방법을 의미합니다. 
    ```c
    print('Hi');
    ```
    ```js
    document.write('Hi');
    ```
    여기서, print와 write 따위를 말합니다. <br />

  **REST API**는 내 컴퓨터의 기능이 아닌 다른 컴퓨터의 기능을 실행시킨다고 할 수 있습니다. 특정 기술을 의미하는 것이 아닌, 웹의 통신 규약인 HTTP를 이용하여 통신할 때, ***HTTP가 가진 잠재력을 최대로 이용할 수 있게 유도하기 위한 모범 사례*** 라고 할 수 있습니다. <br />
  - REST 기반으로 서비스 API를 구현.
  - OpenAPI, 마이크로 서비스 등을 제공하는 업체 대부분이 REST API 제공.<br />

  HTTP URI(Uniform Resource Identifier)를 통해 자원(Resource)을 명시하고, HTTP Method(POST, GET, PUT or PATCH, DELETE)를 통해 [CRUD Operation](#crud-operation)을 적용하는 것을 말합니다.

- **RESTful** <br />
RESTful은 일반적으로 REST라는 아키텍처를 구현하는 웹 서비스를 나타내기 위해 사용되는 용어입니다. REST를 REST답게 쓰기 위한 방법으로, 공식적인 기술 명칭은 아닙니다.
  - REST API를 제공하는 웹 서비스를 RESTful하다고 합니다.
  - REST 원리를 따르는 시스템은 RESTful이란 용어로 지칭됩니다. 

  **RESTful의 목적** <br />
    - 이해와 사용이 쉬운 REST API를 만듭니다.
    - RESTful한 API를 구현하는 근본적인 목적은 성능 향상에 있는 것이 아니라 일관적인 컨벤션을 통한 API의 이해도 및 호환성을 높이는 것입니다. 즉, 성능이 중요한 상황에서 굳이 RESTful한 API를 구현할 필요는 없습니다.


## GraphQL
페이스북이 만든 API를 위한 쿼리 언어입니다. 서버측 런타임으로 **클라이언트에게 요청한 만큼의 데이터를 제공**하는 데 우선 순위를 둡니다. <br /><br />
더욱 빠르고 유연하며, 개발자 친화적으로 만들기 위해 설계되었습니다.

### GraphQL API의 특징
- 주로 하나의 Endpoint를 사용합니다.
- 요청할 때 사용한 Query에 따라 응답 구조가 다릅니다.
- Text 만으로 하기 힘든 File 전송 따위를 처리하기 힘듭니다.

### REST API vs GraphQL
- **HTTP 요청 횟수** : REST API는 각 Resource 종류 별로 요청 해야하지만, GraphQL은 원하는 정보를 하나의 Query에 담아 한 번에 요청합니다.
- **HTTP 응답 Size** : REST API는 응답의 형태가 정해져 있지만, Graph QL은 원하는 대로 정보를 요청하는 것이 가능하기 때문에 불필요하게 거대한 응답을 요청할 필요가 없습니다.

### REST API or GraphQL
- GraphQL
  - 서로 다른 데이터로 응답해야 할 때
  - 대부분의 요청이 CRUD에 해당할 때
- REST API
  - HTTP와 HTTPs에 의한 Caching을 사용할 때
  - File 전송 등 단순한 Text로 처리되지 않는 요청들이 있을 때